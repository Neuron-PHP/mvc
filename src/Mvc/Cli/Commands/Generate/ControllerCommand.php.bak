<?php

namespace Neuron\Mvc\Cli\Commands\Generate;

use Neuron\Cli\Commands\Command;
use Symfony\Component\Yaml\Yaml;

/**
 * CLI command for generating MVC controllers with views and routes.
 *
 * Generates RESTful controllers, Bootstrap 5 views, and route definitions by default.
 * Use --no-views and --no-routes to opt out of view or route generation.
 */
class ControllerCommand extends Command
{
	private string $_ProjectPath;
	private string $_StubPath;
	private array $_Messages = [];

	public function __construct()
	{
		$this->_ProjectPath = getcwd();
		$this->_StubPath = __DIR__ . '/stubs';
	}

	/**
	 * @inheritDoc
	 */
	public function getName(): string
	{
		return 'controller:generate';
	}

	/**
	 * @inheritDoc
	 */
	public function getDescription(): string
	{
		return 'Generate MVC controller with views and routes';
	}

	/**
	 * Configure the command
	 */
	public function configure(): void
	{
		$this->addArgument( 'name', true, 'Controller name (e.g., Post or Admin/Post)' );
		$this->addOption( 'namespace', null, true, 'Controller namespace', 'App\\Controllers' );
		$this->addOption( 'model', null, true, 'Model name (defaults to controller name)' );
		$this->addOption( 'filter', null, true, 'Route filter (e.g., auth)' );
		$this->addOption( 'api', null, false, 'Generate API controller (JSON responses)' );
		$this->addOption( 'no-views', null, false, 'Skip view generation' );
		$this->addOption( 'no-routes', null, false, 'Skip route generation' );
		$this->addOption( 'force', 'f', false, 'Overwrite existing files' );
	}

	/**
	 * Execute the command
	 */
	public function execute( array $Parameters = [] ): int
	{
		$this->output( "\n╔═══════════════════════════════════════╗" );
		$this->output( "║  MVC Controller Generator            ║" );
		$this->output( "╚═══════════════════════════════════════╝\n" );

		// Get controller name
		$controllerName = $this->input->getArgument( 'name' );
		if( empty( $controllerName ) )
		{
			$this->output( "❌ Controller name is required" );
			return 1;
		}

		// Parse controller info
		$info = $this->parseControllerName( $controllerName );
		$info['model'] = $this->input->getOption( 'model', $info['class'] );
		$info['namespace'] = $this->input->getOption( 'namespace', 'App\\Controllers' );
		$info['filter'] = $this->input->getOption( 'filter' );
		$info['isApi'] = $this->input->hasOption( 'api' );

		// Generate controller
		if( !$this->generateController( $info ) )
		{
			return 1;
		}

		// Generate views (unless --no-views or --api)
		if( !$this->input->hasOption( 'no-views' ) && !$info['isApi'] )
		{
			if( !$this->generateViews( $info ) )
			{
				return 1;
			}
		}

		// Generate routes (unless --no-routes)
		if( !$this->input->hasOption( 'no-routes' ) )
		{
			if( !$this->generateRoutes( $info ) )
			{
				return 1;
			}
		}

		// Show summary
		$this->output( "\n✅ Controller generated successfully!\n" );
		foreach( $this->_Messages as $message )
		{
			$this->output( "  " . $message );
		}
		$this->output( "" );

		return 0;
	}

	/**
	 * Parse controller name into components
	 */
	private function parseControllerName( string $name ): array
	{
		// Remove "Controller" suffix if present
		$name = preg_replace( '/Controller$/', '', $name );

		// Split by / or \
		$parts = preg_split( '#[/\\\\]+#', trim( $name, '/\\' ) );

		$class = array_pop( $parts );
		$subNamespace = implode( '\\', $parts );

		// Generate various forms
		$model = $class;
		$models = $this->pluralize( $model );
		$variable = lcfirst( $model );
		$variables = lcfirst( $models );

		// Controller path for views (e.g., Admin/Posts)
		$controllerPath = empty( $subNamespace ) ? $models : $subNamespace . '/' . $models;

		// Route prefix (e.g., /admin/posts)
		$routePrefix = '/' . strtolower( str_replace( '\\', '/', $controllerPath ) );

		return [
			'class' => $class . 'Controller',
			'subNamespace' => $subNamespace,
			'model' => $model,
			'models' => $models,
			'variable' => $variable,
			'variables' => $variables,
			'controllerPath' => $controllerPath,
			'routePrefix' => $routePrefix,
		];
	}

	/**
	 * Generate controller file
	 */
	private function generateController( array $info ): bool
	{
		// Determine full namespace
		$namespace = $info['namespace'];
		if( !empty( $info['subNamespace'] ) )
		{
			$namespace .= '\\' . $info['subNamespace'];
		}

		// Build controller path
		$relativePath = str_replace( '\\', '/', $namespace );
		$relativePath = preg_replace( '#^App/#', 'app/', $relativePath );
		$controllerDir = $this->_ProjectPath . '/' . $relativePath;
		$controllerFile = $controllerDir . '/' . $info['class'] . '.php';

		// Check if exists
		if( file_exists( $controllerFile ) && !$this->input->hasOption( 'force' ) )
		{
			$this->output( "❌ Controller already exists: {$controllerFile}" );
			$this->output( "   Use --force to overwrite" );
			return false;
		}

		// Load stub
		$stubFile = $info['isApi'] ? 'controller.api.stub' : 'controller.resource.stub';
		$stub = $this->loadStub( $stubFile );
		if( !$stub )
		{
			$this->output( "❌ Could not load stub file: {$stubFile}" );
			return false;
		}

		// Replace placeholders
		$content = $this->replacePlaceholders( $stub, array_merge( $info, ['namespace' => $namespace] ) );

		// Create directory
		if( !is_dir( $controllerDir ) )
		{
			if( !mkdir( $controllerDir, 0755, true ) )
			{
				$this->output( "❌ Could not create directory: {$controllerDir}" );
				return false;
			}
		}

		// Write file
		if( file_put_contents( $controllerFile, $content ) === false )
		{
			$this->output( "❌ Could not write controller file" );
			return false;
		}

		$this->_Messages[] = "Created controller: {$controllerFile}";
		return true;
	}

	/**
	 * Generate view files
	 */
	private function generateViews( array $info ): bool
	{
		$viewsDir = $this->_ProjectPath . '/resources/views/' . strtolower( $info['models'] );

		// Create views directory
		if( !is_dir( $viewsDir ) )
		{
			if( !mkdir( $viewsDir, 0755, true ) )
			{
				$this->output( "❌ Could not create views directory: {$viewsDir}" );
				return false;
			}
		}

		// Generate each view
		$views = ['index', 'create', 'edit'];
		foreach( $views as $view )
		{
			$viewFile = $viewsDir . '/' . $view . '.php';

			// Check if exists
			if( file_exists( $viewFile ) && !$this->input->hasOption( 'force' ) )
			{
				$this->output( "⚠️  View already exists, skipping: {$viewFile}" );
				continue;
			}

			// Load stub
			$stub = $this->loadStub( 'view.' . $view . '.stub' );
			if( !$stub )
			{
				$this->output( "❌ Could not load view stub: view.{$view}.stub" );
				return false;
			}

			// Replace placeholders
			$content = $this->replacePlaceholders( $stub, $info );

			// Write file
			if( file_put_contents( $viewFile, $content ) === false )
			{
				$this->output( "❌ Could not write view file: {$viewFile}" );
				return false;
			}

			$this->_Messages[] = "Created view: {$viewFile}";
		}

		return true;
	}

	/**
	 * Generate routes in routes.yaml
	 */
	private function generateRoutes( array $info ): bool
	{
		$routesFile = $this->_ProjectPath . '/config/routes.yaml';

		if( !file_exists( $routesFile ) )
		{
			$this->output( "❌ Routes file not found: {$routesFile}" );
			return false;
		}

		// Load existing routes
		try
		{
			$data = Yaml::parseFile( $routesFile );
		}
		catch( \Exception $e )
		{
			$this->output( "❌ Could not parse routes.yaml: " . $e->getMessage() );
			return false;
		}

		// Build namespace
		$namespace = $info['namespace'];
		if( !empty( $info['subNamespace'] ) )
		{
			$namespace .= '\\' . $info['subNamespace'];
		}
		$controller = $namespace . '\\' . $info['class'];

		// Build routes
		$newRoutes = [
			[
				'method' => 'GET',
				'route' => $info['routePrefix'],
				'controller' => $controller . '@index',
			],
			[
				'method' => 'GET',
				'route' => $info['routePrefix'] . '/create',
				'controller' => $controller . '@create',
			],
			[
				'method' => 'POST',
				'route' => $info['routePrefix'],
				'controller' => $controller . '@store',
			],
			[
				'method' => 'GET',
				'route' => $info['routePrefix'] . '/:id/edit',
				'controller' => $controller . '@edit',
			],
			[
				'method' => 'PUT',
				'route' => $info['routePrefix'] . '/:id',
				'controller' => $controller . '@update',
			],
			[
				'method' => 'DELETE',
				'route' => $info['routePrefix'] . '/:id',
				'controller' => $controller . '@destroy',
			],
		];

		// Add show route for API controllers
		if( $info['isApi'] )
		{
			array_splice( $newRoutes, 1, 0, [[
				'method' => 'GET',
				'route' => $info['routePrefix'] . '/:id',
				'controller' => $controller . '@show',
			]]);
		}

		// Add filter if specified
		if( !empty( $info['filter'] ) )
		{
			foreach( $newRoutes as &$route )
			{
				$route['filter'] = $info['filter'];
			}
		}

		// Add routes to existing data
		if( !isset( $data['routes'] ) || !is_array( $data['routes'] ) )
		{
			$data['routes'] = [];
		}

		$data['routes'] = array_merge( $data['routes'], $newRoutes );

		// Write back to file
		try
		{
			$yaml = Yaml::dump( $data, 10, 2 );
			if( file_put_contents( $routesFile, $yaml ) === false )
			{
				$this->output( "❌ Could not write routes file" );
				return false;
			}
		}
		catch( \Exception $e )
		{
			$this->output( "❌ Could not write routes.yaml: " . $e->getMessage() );
			return false;
		}

		$routeCount = count( $newRoutes );
		$this->_Messages[] = "Added {$routeCount} routes to {$routesFile}";
		return true;
	}

	/**
	 * Load stub file
	 */
	private function loadStub( string $filename ): ?string
	{
		$path = $this->_StubPath . '/' . $filename;
		if( !file_exists( $path ) )
		{
			return null;
		}
		return file_get_contents( $path );
	}

	/**
	 * Replace placeholders in stub content
	 */
	private function replacePlaceholders( string $content, array $replacements ): string
	{
		foreach( $replacements as $key => $value )
		{
			$content = str_replace( '{{' . $key . '}}', $value, $content );
		}
		return $content;
	}

	/**
	 * Simple pluralization
	 */
	private function pluralize( string $word ): string
	{
		// Simple English pluralization rules
		if( preg_match( '/(s|x|z|ch|sh)$/i', $word ) )
		{
			return $word . 'es';
		}
		elseif( preg_match( '/y$/i', $word ) )
		{
			return preg_replace( '/y$/i', 'ies', $word );
		}
		else
		{
			return $word . 's';
		}
	}
}
